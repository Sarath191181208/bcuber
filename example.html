<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <title>Rounded Rubik's Cube (White Up, Green Front with Custom Colors)</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
    }

    canvas {
      display: block;
    }

    /* Simple controls overlay */
    #controls {
      position: absolute;
      top: 10px;
      left: 10px;
      z-index: 100;
      background: rgba(255, 255, 255, 0.8);
      padding: 10px;
      border-radius: 5px;
      font-family: sans-serif;
    }

    #moveInput {
      width: 300px;
    }
  </style>
</head>

<body>
  <!-- Controls overlay for move input -->
  <div id="controls">
    <input type="text" id="moveInput" placeholder="Enter moves e.g. R U R' U'" />
    <button id="submitMoves">Submit</button>
    <div style="font-size: 0.9em; margin-top: 5px;">
      Moves supported: R, R', R2, L, L', L2, U, U', U2, D, D', D2, F, F', F2, B, B', B2
    </div>
  </div>

  <script type="module">
    import * as THREE from 'https://cdnjs.cloudflare.com/ajax/libs/three.js/0.172.0/three.module.js';
    import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three@0.124/examples/jsm/controls/OrbitControls.js';

    // ------------------ Helper: Create Rounded Cube Geometry ------------------
    // This function creates a BoxGeometry with subdivisions and then "rounds" the vertices.
    // Parameters:
    //   width, height, depth – dimensions of the cube
    //   radius – how rounded the edges should be
    //   segments – number of subdivisions per edge (higher = smoother rounding)
    function createRoundedCubeGeometry(width, height, depth, radius, segments) {
      segments = segments || 4;
      // Create a subdivided BoxGeometry.
      const geometry = new THREE.BoxGeometry(width, height, depth, segments, segments, segments);
      const posAttr = geometry.attributes.position;
      // Pre-calculate half-dimensions.
      const halfW = width / 2, halfH = height / 2, halfD = depth / 2;
      for (let i = 0; i < posAttr.count; i++) {
        let x = posAttr.getX(i);
        let y = posAttr.getY(i);
        let z = posAttr.getZ(i);
        // For each axis, clamp the coordinate to the inner box region.
        const ox = THREE.MathUtils.clamp(x, -halfW + radius, halfW - radius);
        const oy = THREE.MathUtils.clamp(y, -halfH + radius, halfH - radius);
        const oz = THREE.MathUtils.clamp(z, -halfD + radius, halfD - radius);
        const dx = x - ox, dy = y - oy, dz = z - oz;
        const len = Math.sqrt(dx * dx + dy * dy + dz * dz);
        if (len > 0) {
          const t = radius / len;
          x = ox + dx * t;
          y = oy + dy * t;
          z = oz + dz * t;
          posAttr.setXYZ(i, x, y, z);
        }
      }
      posAttr.needsUpdate = true;
      geometry.computeVertexNormals();
      return geometry;
    }

    // --------------------- SETUP SCENE, CAMERA, RENDERER ---------------------
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x202020);
    const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
    camera.position.set(5, 5, 5);
    camera.lookAt(0, 0, 0);
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // ------------------------ ORBIT CONTROLS ------------------------
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;

    // -------------------------- LIGHTING --------------------------
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
    scene.add(ambientLight);
    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
    directionalLight.position.set(5, 10, 7.5);
    scene.add(directionalLight);

    // ----------------------- CREATE THE RUBIK'S CUBE -----------------------
    // Our color scheme (assuming white on top, green in front):
    // Right (x=1): Red (#E9573F)
    // Left (x=-1): Orange (#F2C45F)
    // Top (y=1): White (#F5F5F5)
    // Bottom (y=-1): Yellow (#F8F384)
    // Front (z=1): Green (#48C991)
    // Back (z=-1): Blue (#5DADE2)
    const cubeGroup = new THREE.Group();
    scene.add(cubeGroup);
    const cubeSize = 0.95;
    const gap = 0.05;
    // Instead of using BoxGeometry, use our custom rounded cube geometry.
    const geometryRounded = createRoundedCubeGeometry(cubeSize, cubeSize, cubeSize, 0.1, 4);

    function createCubeletMaterials(x, y, z) {
      return [
        new THREE.MeshBasicMaterial({ color: (x === 1 ? 0xE9573F : 0x222222) }), // Right: Red
        new THREE.MeshBasicMaterial({ color: (x === -1 ? 0xF2C45F : 0x222222) }), // Left: Orange
        new THREE.MeshBasicMaterial({ color: (y === 1 ? 0xF5F5F5 : 0x222222) }),  // Top: White
        new THREE.MeshBasicMaterial({ color: (y === -1 ? 0xF8F384 : 0x222222) }), // Bottom: Yellow
        new THREE.MeshBasicMaterial({ color: (z === 1 ? 0x48C991 : 0x222222) }),  // Front: Green
        new THREE.MeshBasicMaterial({ color: (z === -1 ? 0x5DADE2 : 0x222222) })   // Back: Blue
      ];
    }

    // Create cubelets in a 3×3×3 grid (skip the center piece)
    const cubelets = [];
    for (let x = -1; x <= 1; x++) {
      for (let y = -1; y <= 1; y++) {
        for (let z = -1; z <= 1; z++) {
          if (x === 0 && y === 0 && z === 0) continue;
          const materials = createCubeletMaterials(x, y, z);
          // Use our rounded geometry for each cubelet.
          const cubelet = new THREE.Mesh(geometryRounded, materials);
          cubelet.position.set(
            x * (cubeSize + gap),
            y * (cubeSize + gap),
            z * (cubeSize + gap)
          );
          // Save the "logical" grid coordinate (for move selection) in userData.
          cubelet.userData.logicalPos = new THREE.Vector3(x, y, z);
          cubeGroup.add(cubelet);
          cubelets.push(cubelet);
        }
      }
    }

    // --------------------- MOVE QUEUE & MOVE MAPPING ---------------------
    // Coordinate system:
    //   y positive: Up (white)
    //   y negative: Down (yellow)
    //   z positive: Front (green)
    //   z negative: Back (blue)
    //   x positive: Right (red)
    //   x negative: Left (orange)
    const moveQueue = [];
    const moveMapping = {
      "R": { axis: "x", layer: 1, angle: -Math.PI / 2 },
      "R'": { axis: "x", layer: 1, angle: Math.PI / 2 },
      "R2": { axis: "x", layer: 1, angle: -Math.PI },
      "L": { axis: "x", layer: -1, angle: Math.PI / 2 },
      "L'": { axis: "x", layer: -1, angle: -Math.PI / 2 },
      "L2": { axis: "x", layer: -1, angle: Math.PI },
      "U": { axis: "y", layer: 1, angle: -Math.PI / 2 },
      "U'": { axis: "y", layer: 1, angle: Math.PI / 2 },
      "U2": { axis: "y", layer: 1, angle: -Math.PI },
      "D": { axis: "y", layer: -1, angle: Math.PI / 2 },
      "D'": { axis: "y", layer: -1, angle: -Math.PI / 2 },
      "D2": { axis: "y", layer: -1, angle: Math.PI },
      "F": { axis: "z", layer: 1, angle: -Math.PI / 2 },
      "F'": { axis: "z", layer: 1, angle: Math.PI / 2 },
      "F2": { axis: "z", layer: 1, angle: -Math.PI },
      "B": { axis: "z", layer: -1, angle: Math.PI / 2 },
      "B'": { axis: "z", layer: -1, angle: -Math.PI / 2 },
      "B2": { axis: "z", layer: -1, angle: Math.PI }
    };

    // --------------------- UTILITY: Rotate Logical Position ---------------------
    function rotateLogical(pos, axis, angle) {
      let axisVec;
      if (axis === 'x') axisVec = new THREE.Vector3(1, 0, 0);
      else if (axis === 'y') axisVec = new THREE.Vector3(0, 1, 0);
      else if (axis === 'z') axisVec = new THREE.Vector3(0, 0, 1);
      let newPos = pos.clone();
      newPos.applyAxisAngle(axisVec, angle);
      newPos.x = Math.round(newPos.x);
      newPos.y = Math.round(newPos.y);
      newPos.z = Math.round(newPos.z);
      return newPos;
    }

    // --------------------- MOVE ANIMATION VARIABLES ---------------------
    let rotatingFlag = false;       // Whether a move is in progress
    let currentGroup = null;        // Temporary group for the moving layer
    let rotationAxis = null;        // 'x', 'y', or 'z'
    let targetAngle = 0;            // Total rotation (radians) for the move
    let rotatedAngle = 0;           // Accumulated rotation so far in the current move
    const rotationSpeed = Math.PI / 100; // Rotation increment per frame

    function startMove(moveObj) {
      rotatingFlag = true;
      rotationAxis = moveObj.axis;
      targetAngle = moveObj.angle;
      currentGroup = new THREE.Group();
      cubeGroup.add(currentGroup);
      const threshold = 0.1;
      const cubesToRotate = [];
      for (const cube of cubelets) {
        const pos = cube.userData.logicalPos;
        if (Math.abs(pos[rotationAxis] - moveObj.layer) < threshold) {
          cubesToRotate.push(cube);
        }
      }
      for (const cube of cubesToRotate) {
        currentGroup.add(cube);
      }
      rotatedAngle = 0;
    }

    // --------------------- HANDLE MOVE INPUT ---------------------
    document.getElementById("submitMoves").addEventListener("click", () => {
      const input = document.getElementById("moveInput").value;
      const tokens = input.trim().split(/\s+/);
      for (const token of tokens) {
        if (moveMapping[token]) {
          moveQueue.push(moveMapping[token]);
        }
      }
      document.getElementById("moveInput").value = "";
    });

    // --------------------- MAIN ANIMATION LOOP ---------------------
    function animate() {
      requestAnimationFrame(animate);
      controls.update();

      if (!rotatingFlag && moveQueue.length > 0) {
        const nextMove = moveQueue.shift();
        startMove(nextMove);
      }

      if (rotatingFlag && currentGroup) {
        let deltaAngle = targetAngle > 0 ? rotationSpeed : -rotationSpeed;
        if (targetAngle > 0) {
          if (rotatedAngle + deltaAngle > targetAngle) {
            deltaAngle = targetAngle - rotatedAngle;
          }
        } else {
          if (rotatedAngle + deltaAngle < targetAngle) {
            deltaAngle = targetAngle - rotatedAngle;
          }
        }
        rotatedAngle += deltaAngle;
        currentGroup.rotation[rotationAxis] += deltaAngle;

        if (Math.abs(rotatedAngle) >= Math.abs(targetAngle) - 0.0001) {
          currentGroup.updateMatrixWorld(true);
          const children = currentGroup.children.slice();
          for (const cube of children) {
            cubeGroup.attach(cube);
            cube.userData.logicalPos = rotateLogical(cube.userData.logicalPos, rotationAxis, targetAngle);
          }
          cubeGroup.remove(currentGroup);
          currentGroup = null;
          rotatingFlag = false;
        }
      }

      renderer.render(scene, camera);
    }
    animate();

    // --------------------- HANDLE WINDOW RESIZE ---------------------
    window.addEventListener("resize", () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>

</html>