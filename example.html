<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Animated Rubik's Cube with Three.js</title>
  <style>
    body { margin: 0; overflow: hidden; }
    canvas { display: block; }
  </style>
</head>
<body>
  <!-- We use only the module import -->
  <script type="module">
    import * as THREE from 'https://cdnjs.cloudflare.com/ajax/libs/three.js/0.172.0/three.module.js';

    // ----- SETUP SCENE, CAMERA, RENDERER -----
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x202020);

    const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
    camera.position.set(5, 5, 5);
    camera.lookAt(0, 0, 0);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // ----- ADD LIGHTING -----
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
    scene.add(ambientLight);
    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
    directionalLight.position.set(5, 10, 7.5);
    scene.add(directionalLight);

    // ----- CREATE THE RUBIK'S CUBE PIECES -----
    // We'll create 26 cubelets (skipping the center) arranged in a 3x3x3 grid.
    const cubelets = [];
    const cubeSize = 0.95;  // size of each mini-cube
    const gap = 0.05;       // gap between cubelets
    const geometry = new THREE.BoxGeometry(cubeSize, cubeSize, cubeSize);

    // Function to create an array of 6 materials for each cubelet.
    // For a standard Rubik’s cube, we color the outer faces:
    // right: green, left: blue, top: white, bottom: yellow, front: red, back: orange.
    // If a face is not on the outer side (coordinate ≠ ±1), it will still be given the same color.
    function createCubeletMaterials(x, y, z) {
      return [
        new THREE.MeshBasicMaterial({ color: (x === 1 ? 0x00ff00 : 0x222222) }), // right face
        new THREE.MeshBasicMaterial({ color: (x === -1 ? 0x0000ff : 0x222222) }), // left face
        new THREE.MeshBasicMaterial({ color: (y === 1 ? 0xffffff : 0x222222) }), // top face
        new THREE.MeshBasicMaterial({ color: (y === -1 ? 0xffff00 : 0x222222) }), // bottom face
        new THREE.MeshBasicMaterial({ color: (z === 1 ? 0xff0000 : 0x222222) }), // front face
        new THREE.MeshBasicMaterial({ color: (z === -1 ? 0xffa500 : 0x222222) })  // back face
      ];
    }

    // Create and position the cubelets.
    // Skip the center cubelet (0,0,0) so that no grey inner piece is ever visible.
    for (let x = -1; x <= 1; x++) {
      for (let y = -1; y <= 1; y++) {
        for (let z = -1; z <= 1; z++) {
          if (x === 0 && y === 0 && z === 0) continue; // Skip the center
          const materials = createCubeletMaterials(x, y, z);
          const cubelet = new THREE.Mesh(geometry, materials);
          cubelet.position.set(
            x * (cubeSize + gap),
            y * (cubeSize + gap),
            z * (cubeSize + gap)
          );
          // Save its logical (grid) position for later layer selection.
          cubelet.userData.logicalPos = new THREE.Vector3(x, y, z);
          scene.add(cubelet);
          cubelets.push(cubelet);
        }
      }
    }

    // ----- ANIMATION VARIABLES FOR LAYER ROTATION -----
    let rotating = false;
    let currentGroup = null;
    let rotationAxis = null;   // 'x', 'y', or 'z'
    let targetAngle = 0;       // total angle to rotate (±90°)
    let rotatedAngle = 0;      // how much we've rotated so far
    const rotationSpeed = Math.PI / 100;  // rotation step per frame

    // ----- FUNCTION TO START A RANDOM LAYER ROTATION -----
    function startRandomRotation() {
      if (rotating) return;
      rotating = true;

      // Randomly choose an axis.
      const axes = ['x', 'y', 'z'];
      rotationAxis = axes[Math.floor(Math.random() * axes.length)];

      // Randomly choose a layer index (-1, 0, or 1).
      const layers = [-1, 0, 1];
      const layerIndex = layers[Math.floor(Math.random() * layers.length)];

      // Randomly choose the rotation direction (clockwise or counter-clockwise).
      const direction = Math.random() < 0.5 ? 1 : -1;
      targetAngle = direction * Math.PI / 2;  // 90° rotation

      // Create a temporary group to hold the cubelets in this layer.
      currentGroup = new THREE.Group();
      scene.add(currentGroup);

      // Select cubelets whose logical coordinate (for the chosen axis) is near the chosen layer.
      const threshold = 0.1;
      const cubesToRotate = [];
      for (const cubelet of cubelets) {
        const pos = cubelet.userData.logicalPos;
        if (Math.abs(pos[rotationAxis] - layerIndex) < threshold) {
          cubesToRotate.push(cubelet);
        }
      }

      // Remove selected cubelets from the scene and add them to the group.
      for (const cube of cubesToRotate) {
        currentGroup.add(cube);
      }

      rotatedAngle = 0;
    }

    // ----- MAIN ANIMATION LOOP -----
    function animate() {
      requestAnimationFrame(animate);

      // (Optional) Slowly rotate the entire scene for a better view.
      scene.rotation.y += 0.005;

      // If a layer is currently rotating, update its rotation.
      if (rotating && currentGroup) {
        let deltaAngle = rotationSpeed;
        // Make sure we do not overshoot the target angle.
        if (Math.abs(rotatedAngle + deltaAngle) > Math.abs(targetAngle)) {
          deltaAngle = targetAngle - rotatedAngle;
        }
        rotatedAngle += deltaAngle;
        currentGroup.rotation[rotationAxis] += deltaAngle;

        // Once the target 90° rotation is reached…
        if (Math.abs(rotatedAngle) >= Math.abs(targetAngle) - 0.0001) {
          // Update each cubelet’s world transform.
          currentGroup.updateMatrixWorld(true);
          // Detach each cubelet from the group and reattach it to the scene (preserving its world transform).
          const children = currentGroup.children.slice(); // copy list
          for (const cube of children) {
            scene.attach(cube);

            // Update the logical position by applying a 90° rotation in the appropriate plane.
            const pos = cube.userData.logicalPos;
            const newPos = pos.clone();
            if (rotationAxis === 'x') {
              if (targetAngle > 0) {
                newPos.y = -pos.z;
                newPos.z = pos.y;
              } else {
                newPos.y = pos.z;
                newPos.z = -pos.y;
              }
            } else if (rotationAxis === 'y') {
              if (targetAngle > 0) {
                newPos.x = pos.z;
                newPos.z = -pos.x;
              } else {
                newPos.x = -pos.z;
                newPos.z = pos.x;
              }
            } else if (rotationAxis === 'z') {
              if (targetAngle > 0) {
                newPos.x = -pos.y;
                newPos.y = pos.x;
              } else {
                newPos.x = pos.y;
                newPos.y = -pos.x;
              }
            }
            cube.userData.logicalPos = newPos;
            // Snap the cubelet’s position to its new logical grid coordinate.
            cube.position.set(
              newPos.x * (cubeSize + gap),
              newPos.y * (cubeSize + gap),
              newPos.z * (cubeSize + gap)
            );
            // Reset its rotation so that each cubelet remains axis–aligned.
            cube.rotation.set(0, 0, 0);
            // Update the cubelet's materials based on its new logical position.
            cube.material = createCubeletMaterials(newPos.x, newPos.y, newPos.z);
          }

          // Remove the temporary group and mark the rotation as finished.
          scene.remove(currentGroup);
          currentGroup = null;
          rotating = false;

          // Start another random rotation after a short delay.
          setTimeout(startRandomRotation, 500);
        }
      }

      renderer.render(scene, camera);
    }

    // Start the first rotation after 1 second.
    setTimeout(startRandomRotation, 1000);
    animate();

    // ----- HANDLE WINDOW RESIZE -----
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
